# 概要

線形探索のコードをPythonで書いてみます。

## ゴール

線形探索とは何か・どのように考えればコードを組み立てられるのか理解することを目指します。

### 線形探索とは

線形探索は、リストを先頭から順に探索することで目的の要素を探し出すアルゴリズムです。 先頭から次の要素、更に次の要素と、リストを一直線の形に探索していくことから、線形と呼ばれています。

## 実装

線形探索はシンプルでとっつきやすいアルゴリズムなので、早速実装へと進んでいきましょう。

### 方針決め

探索方法をどのようにコードで表現するかを考えることから始めます。頭の中でアルゴリズムをコードへ変換する場合、次の手順で書いていくと迷いづらくなるはずです。

* アルゴリズムを単純な方法の集まりに分ける
* 母国語で擬似コードを書いてみる

これに従って考えてみましょう。

### アルゴリズムの解釈

リストを一直線に走査するだけなので、これ以上分解する必要はなさそうです。一直線に調べるということは、forループで順に要素を探索することで実現できます。

### 擬似コード

いきなり実装コードを書いても良さそうですが、基礎の段階から流れを固めておくためにも、まずは擬似コードを書いてみます。

```Python
def 線形探索(探すリスト, 探したい要素):
    for 要素 in 探すリスト:
        if 要素 == 探したい要素:
            return 今見ている探すリストのインデックス

    return None
```

forループで探索対象のリストを順に走査し、目的の要素が見つかれば対象のインデックスを・見つからなければNoneを返却します。 本当はインデックスをリストから得るために少し工夫が必要ですが、ここではコードの雰囲気をイメージすることが重要なので割愛しています。
複雑な処理もこのように骨組みを組み立ててから肉付けしていくと、少しずつ立ち向かえるようになるはずです。


### コード

擬似コードで大まかな流れを掴めたはずなので、いよいよコード本体を書いてみることにします。とはいえ命名や型ヒントなどが少し加わったぐらいですので、擬似コードと容易に対応付けられるかと思います。早速見てみましょう。

```Python
from typing import Union


# Python3.10以降であれば、戻り値の型は`int | None`と表現することもできます
def search_by_linear(search_list: list[int], target: int) -> Union[int, None]:
    """
    線形探索でリストから対象要素を探索

    :param search_list: 探索対象リスト
    :param target: 探索対象
    :return: 対象が存在->リスト内のインデックス 存在なし->None
    """

    for index, item in enumerate(search_list):
        if item == target:
            return index

    return None
```

さて、できあがったコードを眺めてみると、文法的には特に難しいところはないかと思います。しかし、`なぜ探索処理を関数で分けたのか`・`なぜリストや探索要素を引数で受け取るのか`など、なぜそのような記述となったのかは、完成形だけでは見えづらくなってしまっています。
書いたコードの背景を言語化することができるようになれば、コードの理解もぐっと進むはずです。早速見てみましょう。

### なぜ探索処理を関数で独立させたのか

まずは、線形探索をコードで実現するとき、関数で記述した理由から追っていきます。
例えば、`線形探索でリストに目的の要素が存在するか走査したい`ということであれば、

* main処理にべた書き
* 結果をprintする処理も含めて関数化
* 探索処理だけを関数化
* リスト・探索要素を属性に持ち、探索処理をメソッドに持つクラスを定義

などの実装方法が考えられます。多くの選択肢がある中、なぜ関数で書くことを選んだのでしょうか。
これは、線形探索に必要な処理を最もシンプルに表現できると判断したからです。

main処理にすべてを書いていると、一度に頭に入れておくもの(変数のスコープ・処理の境界など)が増えて読みづらくなってしまいます。
クラスは線形探索に関わるものを集約させることができますが、関数に比べると記述量が増えて探索処理を表現するには、やや大仰に見えるかもしれません。
※ クラス・関数どちらを選ぶかは状況によって変わりますし、好みによるところもあるので、今回は好きな方で書くのもよいと思います。

関数で線形探索を表現してみると、処理の範囲は短くまとまっていますし、変数の型・スコープも明確で読みやすい...はずです。
以上のことから、単純なアルゴリズムであれば、以降も関数で記述していくことにします。

### なぜ関数はリスト・探索要素を引数に受け取り、探索結果を返すのか

さて、関数で線形探索を書くことに決めても、まだ書き方には検討の余地があります。特に関数を定義するときに考えるべきは、「何を入力とし、何を出力とするか」です。それぞれ考えてみましょう。

#### 出力

まず関数を書くときは、こういう値を返してくれる関数が欲しいなー、といったところから始まります。ですので、関数の出力から見ていきます。
ここで注目すべきは、関数内部で結果をprint文で出力するのではなく、探索結果としてリスト内の探索要素のインデックス/Noneを返却していることです。

このように値を生成する処理・値をもとになんらかの命令を実行する処理を分けておくと、後ほど触れるテストコードが書きやすくなります。
関数の戻り値のみをテストするのと、関数内部で線形探索の結果が○○になるから、print文でこういう文が出力されるはず、といったことをテストするのとでは、テストの労力が大きく異なります。
これは、実際にテストコードを見た方が分かりやすいので、ひとまずは処理を「入力をもとに値を返す関数」の単位に切り出せるとテストが書きやすくなるんだな、ということを覚えておきましょう。

#### 入力

関数が返すものが定まったので、続いて、何を入力として値をつくり出すのか、考えることにします。

---

## テストコード

## まとめ